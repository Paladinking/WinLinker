u32 a;
u32 b;
start {
    a = 11 * 12;
    b = a + a;
    if 2 == 1 {
        a = 20;
    } else if b == 2 && a == 1 {
        a = 11;
        b = 23;
    } else {
        b = 9;
        if 1 == 1 {
            a = 1;
        } else {
            a = b;
        }
    }
    exit_code = a + b;
} end
// 2 bugs?
//  Variable 'a' is (marked as) temp_freed after 'if a == 1'
//  Weird scope correction after exiting first if branch
//FUCK
//Usage_tracker does not work at all...
                                          |

u32 a;
u32 b;
bool c;
start {
    a = 10;
    b = 20;
    c = a * b > 15 * 16;
    if a >= b && (c || b < 19) {
        a = 12;
    } else if c == false {
        a = 24;
    } else {
        a = 123;
    }
    exit_code = a;
} end

mov rax, 10
mov REGB, 20
mov REGC, rax
mul REGB
mov REGD, rax
mov rax, 15
mov REGE, 15
mul REGE
cmp REGD, rax
jmpA AFTER_IF
mov REGC, 12
AFTER_IF:
mov rax, REGC

u32 a;
u32 b;
bool c;
start {
    b = 20;
    c = b * b > 15 * 15;
    if a >= b && c {
        a = 12;
    } else {
        a = 10;
    }
    exit_code = a;
} end

GOAL = NONE means fallthrough


Short-circuiting pseudocode
Rules:
	1. Push root with TRUE_GOAL = NONE, FALSE_GOAL = ELSE
	2. Pop expression from stack
	3. Check expression
	3a. && =>
		FALSE_GOAL_2 = FALSE_GOAL.map_none(AFTER)
		Push child 2 with TRUE_GOAL = TRUE_GOAL, FALSE_GOAL = FALSE_GOAL
		Push child 1 with TRUE_GOAL = NONE, FALSE_GOAL = FALSE_GOAL_2

	3b. || =>
		TRUE_GOAL_2 = TRUE_GOAL.map_none(AFTER)
		Push child 2 with TRUE_GOAL = TRUE_GOAL, FALSE_GOAL = FALSE_GOAL
		Push child 1 with TRUE_GOAL = TRUE_GOAL_2, FALSE_GOAL = NONE
	3c. ! =>
	    Push child 1 with TRUE_GOAL = FALSE_GOAL, FALSE_GOAL = TRUE_GOAL
	3d. expr =>
		add Eval(expr)
		if Some(TRUE_GOAL):
			add JMP expr TRUE_GOAL
			If Some(FALSE_GOAL) add JMP FALSE_GOAL
		else:
			add JMP NOT expr FALSE_GOAL

