
u32 a;
start {
    a = 10;

    return a + 20;
} end

u32 a;
u32 b;
start {
    a = 6;
    b = 0;
    while b < 100 {
        a = a + 10;
        b = b + 20;
    }
    return a + b;
    b = 11 * 12;
    a = a * a;
    if 2 == 1 {
        a = 20;
    } else if b == 2 && b == 1 {
        a = 11;
        b = 23;
    } else {
        b = 9;
        if 1 == 1 {
            a = 1;
        } else {

        }
    }
    return a + b;
} end


u32 x1;
u32 x2;
u32 x3;
u32 x4;
u32 x5;
u32 x6;
u32 x7;
u32 x8;
u32 x9;
u32 x10;
u32 x11;
u32 x12;
u32 x13;
u32 x14;
u32 x15;
u32 x16;
u32 x17;
u32 x18;
u32 x19;
u32 x20;
start {
    x1 = 1;
    x2 = 2;
    x3 = 3;
    x4 = 4;
    x5 = 5;
    x6 = 6;
    x7 = 7;
    x8 = 8;
    x9 = 9;
    x10 = 10;
    x11 = 11;
    x12 = 12;
    x13 = 13;
    x14 = 14;
    x15 = 15;
    x16 = 16;
    x17 = 17;
    x18 = 18;
    x19 = 19;
    x20 = 20;

    if x20 > x10 {
        x11 = x3;
    }
    x20 = x2 + x4 + x6 + x8 + x10 +x12 +   x14 + x16 + x18 + x20;
    exit_code = x1 + x3 + x5 + x7 + x9 + x11 + x13 + x15 + x17 + x19 + x20;
} end












u32 a;
u32 b;
bool c;
start {
    a = 10;
    b = 20;
    c = a * b > 15 * 16;
    if a >= b && (c || b < 19) {
        a = 12;
    } else if c == false {
        a = 24;
    } else {
        a = 123;
    }
    exit_code = a;
} end

mov rax, 10
mov REGB, 20
mov REGC, rax
mul REGB
mov REGD, rax
mov rax, 15
mov REGE, 15
mul REGE
cmp REGD, rax
jmpA AFTER_IF
mov REGC, 12
AFTER_IF:
mov rax, REGC

u32 a;
u32 b;
bool c;
start {
    b = 20;
    c = b * b > 15 * 15;
    if a >= b && c {
        a = 12;
    } else {
        a = 10;
    }
    exit_code = a;
} end

GOAL = NONE means fallthrough


Short-circuiting pseudocode
Rules:
	1. Push root with TRUE_GOAL = NONE, FALSE_GOAL = ELSE
	2. Pop expression from stack
	3. Check expression
	3a. && =>
		FALSE_GOAL_2 = FALSE_GOAL.map_none(AFTER)
		Push child 2 with TRUE_GOAL = TRUE_GOAL, FALSE_GOAL = FALSE_GOAL
		Push child 1 with TRUE_GOAL = NONE, FALSE_GOAL = FALSE_GOAL_2

	3b. || =>
		TRUE_GOAL_2 = TRUE_GOAL.map_none(AFTER)
		Push child 2 with TRUE_GOAL = TRUE_GOAL, FALSE_GOAL = FALSE_GOAL
		Push child 1 with TRUE_GOAL = TRUE_GOAL_2, FALSE_GOAL = NONE
	3c. ! =>
	    Push child 1 with TRUE_GOAL = FALSE_GOAL, FALSE_GOAL = TRUE_GOAL
	3d. expr =>
		add Eval(expr)
		if Some(TRUE_GOAL):
			add JMP expr TRUE_GOAL
			If Some(FALSE_GOAL) add JMP FALSE_GOAL
		else:
			add JMP NOT expr FALSE_GOAL

