u32 a;
u32 b;
u32 c;
u32 x1;
u32 x2;
u32 x3;
u32 x4;
u32 x5;
u32 x6;
u32 x7;
u32 x8;
u32 x9;
u32 x10;
u32 x11;
u32 x12;
u32 x13;
u32 x14;
u32 x15;
u32 x16;
u32 x17;
u32 x18;
u32 x19;
u32 x20;
bool d;

start {
x1 = 1;
x2 = 2;
x3 = 3;
x4 = 4;
x5 = 5;
x6 = 6;
x7 = 7;
x8 = 8;
x9 = 9;
x10 = 10;
x11 = 11;
x12 = 12;
x13 = 13;
x14 = 14;
x15 = 15;
x16 = 16;
x17 = 17;
x18 = 18;
x19 = 19;
x20 = 20;
a = 5;
c = 9;
b = 5;
d = 100 > a && true != false || !(20 * 30 >= 15);
a = 10 * b / 11;
c = a + c + x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 +
 x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20;
exit_code = c + 100;
} end


Usages:
    Map block-id + operand-id to vec of ranges
    Inner scopes that contains usages in outer scopes have usage covering to the end of the inner scope
    An operand can be freed if not used later by current scope.


on each variable, associate scope
    variables in a scope outside what is being parsed should NOT be moved.
    if the register is needed, the variable should be moved back.
    Maybe free the register before the scope? (Using hints?)
    Important that exiting the scope, everything looks the same as before the scope to the allocator
        This allows parsing the next branch of an if-statement without reverting stuff.
        Also required for loops to work well.
        How???
        What if variable is declared out of scope but initialized in scope?
            Allocate register on decleration?
            Allocate register before scope?
                How?
            Insert a Mov_ operations at the end of each scope to make sure they get to the right place!
                What place is right?
                Something clever
                Decide before (using hints + invalidations), but don't allocate.
                    No, loops will not work then.
                Allocate just before scope AND add Mov_ operations
                Scope needs to keep track of all used variables from higher scope.



