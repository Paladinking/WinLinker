u32 x1;
u32 x2;
u32 x3;
u32 x4;
u32 x5;
u32 x6;
u32 x7;
u32 x8;
u32 x9;
u32 x10;
u32 x11;
u32 x12;
u32 x13;
u32 x14;
u32 x15;
u32 x16;
u32 x17;
u32 x18;
bool d;
start
x1 = 0;
x2 = 1;
x3 = 2;
x4 = 10;
x5 = 124;
x6 = 999;
x7 = 124;
x8 = 12;
x9 = 11;
x10 = 5;
x11 = 888;
x12 = 123;
x13 = 10;
x14 = 11;
x15 = 12;
x16 = 13;
x17 = 14;
x18 = 15;
exit_code = x2 * x1 * x3 * x4 * x5 * x6 * x7 * x8 * x9 * x10 * x11 * x12 * x13 * x14 * x15 * x16 * x17 * x18;
end


b = ((((b * 4) - 3) - 4) - 5) + a
a = a + b
a = a * 4

Fel just nu:
d:s register blir inte avalokerat
c blir inte allokerat alls
destinationen kanske Ã¤r allokerad redan!


_a = 4             _a[0:12, true]
_b = 2             _b[1:11, true]
_c = 2             _c[2:4, true]
_d = 4             _d[3:4, true]
_e = _c * _d       _e[4:6, false]
_f = 3             _f[5:6, true]
_g = _e - _f       _g[6:8, false]
_h = 4             _h[7:8, true]
_i = _g - _h       _i[8:10, false]
_j = 5             _j[9:10, true]
_k = _i - _j       _k[10:11, false]
_l = _b + _k       _l[11:12, false]
c = _a * _l        c[12:12, false]






c = c * _l             c = rax, _a = c, _l = reg/mem
c = 4
_l = _l + 2        (symmetric),_l = rcx, _b = im(2), _k = _l
_l = _l - 5         _i = _l, _j = im(5)
-
_l = _l - 4         _g = _l, _h = im(4)
-
_l = _l - 3         _e:= _l, _f = im(3)
_l = _e
-
_e = _e * _d        _e = rax, _d = rcx
_e = 2
_d = 4

rcx = 4
rax = 2
rax = rax * rcx
rcx = rax
rcx = rcx - 3
rcx  = rcx - 4
rcx = rcx - 5
rcx = rcx + 2
rax = 4
rax = rax * rcx

mov rcx, 4
mov rax, 2
mul rcx
mov rcx, rax
sub rcx, 3
sub rcx, 4
sub rcx, 5
add rcx, 2
mov rax, 4
mul rcx


algorithm:
    turn tree into list of pseudo_instructions collect variables, assignment, first use, last use, is imm
    move all pseudo_instructions to just before first use
    go from back of list:
        if dual:
            if (var_2.is_imm or var_1.is_imm and symmetric) and has fitting mnemonic:
                choose that mnemonic
            if required(op0 == op1):
                if type_overlap(var_0, var_1):
                    var_1 := var_0
                else:
                    prepend instruction var_1 = var_0
                var_0 = choose reg / mem
            else if allowed(op0 == op1) and type_overlap(var_0, var_1):
                var_1 := var_0
                var_0 = choose reg / mem
            else:
                var_0 = choose reg / mem
                var_1 = choose reg / mem


struct MiniVar {
    imm : bool,
    creation : usize,
    first_use : usize,
    last_use : usize
}

enum MiniOperation {
    Imm(u64),
    Add {op1 : usize, op2 : usize},
    Sub {op1 : usize, op2 : usize},
    MulSigned {op1 : usize, op2 : usize},
    DivSigned {op1 : usize, op2 : usize},
    MulUnsigned {op1 : usize, op2 : usize},
    DivUnsigned {op1: usize, op2 : usize},
    Not {op1 : usize},
}

struct MiniStatement {
    var : usize,
    operation : MiniOperation,
    dest : usize,
}